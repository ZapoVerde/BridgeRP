ğŸ“˜ REQUIREMENTS & STRUCTURE ARTIFACT â€” TEMPLATE FOR ARCHITECT INPUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

This document is the sole planning artifact for use by the AI Software Architect. It contains clarified requirements, structural expectations, and design constraints. It references â€” but does not restate â€” governing principles or tagging standards.

This artifact is generated by the Facilitator AI and reflects all clarified project decisions up to this point.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SECTION 1 â€” PROJECT INTENT SUMMARY  (Planning Phase 1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Describe the purpose of the system at a high level. This is *not* a feature list or technical breakdown. Instead, it should express:

- What this system is trying to accomplish
- Who or what it serves (user-facing, service-facing, internal?)
- The nature of its logic (simulation, workflow, orchestration, etc.)
- Its final expected form (library, tool, engine, application?)

Example expectations for this section: â†’ Should be 3â€“5 sentences describing the â€œwhyâ€ behind the build\
â†’ Avoid low-level implementation terms\
â†’ May include genre, domain, or user scenario if known

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SECTION 2 â€” REQUIRED CAPABILITIES  (Planning Phase 2) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ This section lists all *non-negotiable functional capabilities* of the system. These are outputs or behaviors the system must produce, regardless of how it's implemented.

Example expectations:

- Each bullet should describe a functional requirement
- Include both runtime behaviors and architectural necessities
- Clarify *must-have* features vs optional
- Avoid internal phrasing like â€œshould be modularâ€ unless you mean â€œmust support runtime domain loadingâ€

Also include:

- External interfacing constraints (e.g. â€œMust expose a JSON APIâ€)
- Critical compatibility requirements (e.g. â€œMust run on mobile hardwareâ€)
- User flow expectations (if applicable)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SECTION 3 â€” DESIGN CONSTRAINTS  (Planning Phase 3) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ This section covers *non-functional* rules that govern how the system is to be built or structured. This includes philosophical rules, enforced boundaries, and coding-level constraints.

Expectations:

- Include all relevant constraints such as:
  - Programming language version
  - Required test framework
  - Rules around mutability or global state
  - Observability/logging requirements
- May reference tooling policies (e.g. must support structured debug output)
- If the project requires separation of logic, declare how (e.g. Core vs Systems vs UI)

If certain anti-patterns are banned (e.g. circular imports, direct file I/O in logic modules), specify them clearly.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SECTION 4 â€” ARCHITECTURAL SHAPE  (Planning Phase 4) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ This section outlines the *expected structural shape* of the system, in abstract terms. It defines how modules are expected to be grouped or layered â€” without naming specific files.

Guidance:

- Declare the major layers of the system (e.g. Core, Systems, Interface)
- Describe if features are organized by *domain* (e.g. combat, inventory) or *role* (e.g. processors, emitters)
- Specify any known architectural patterns to be followed (e.g. event bus, adapter routing, plugin registration)
- If system must be sliceable into deployable vertical features (e.g. milestone-based), say so

Do not describe implementation or file layout here. Thatâ€™s for the architecture plan. Instead, define the expected *conceptual partitioning* of responsibilities.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SECTION 5 â€” GOVERNING PRINCIPLES (EXTERNAL)  (Planning Phase 5) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ This section *references* external principle documents that must be followed during architecture generation. These define things like file structure, tagging rules, adapter constraints, and debug policy.

Expectations:

- Do not duplicate rules here â€” list the filenames and their function
- Must include any locked architectural principle files
- Must include any tag vocabulary definitions (if required at planning stage)

Example entry:

```
- Architectural_Principles.txt â€” Defines allowed layers, purity rules, adapter boundaries
- tags_vocab.json â€” Defines MECE tagging groups for all functions and files
- DebuggerContract.txt â€” Defines structure of debug output and logging obligations
```

If no such documents exist yet, leave this section empty or write `None yet declared`.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SECTION 6 â€” OUTSTANDING OPEN QUESTIONS (OPTIONAL)  (Planning Phase 6) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ List any unresolved decisions or ambiguities that arose during facilitation. These are not blockers but should be addressed early by the architect.

Include:

- Missing declarations (e.g. â€œEvent system is assumed but not confirmedâ€)
- Unclear priorities (e.g. â€œPerformance vs memory usage tradeoff not declaredâ€)
- Risk flags (e.g. â€œData format is not yet finalizedâ€)

This section is optional but highly recommended when the upstream conversation includes assumptions.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

This document concludes the planning phase. No additional prompts, assumptions, or profiles are to be applied by the architect.

