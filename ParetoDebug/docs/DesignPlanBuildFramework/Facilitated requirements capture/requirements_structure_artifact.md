📘 REQUIREMENTS & STRUCTURE ARTIFACT — TEMPLATE FOR ARCHITECT INPUT ────────────────────────────────────────────────────────────────────

This document is the sole planning artifact for use by the AI Software Architect. It contains clarified requirements, structural expectations, and design constraints. It references — but does not restate — governing principles or tagging standards.

This artifact is generated by the Facilitator AI and reflects all clarified project decisions up to this point.

──────────────────────────────────────────────────────────── SECTION 1 — PROJECT INTENT SUMMARY  (Planning Phase 1) ──────────────────────────────────────────────────────────── Describe the purpose of the system at a high level. This is *not* a feature list or technical breakdown. Instead, it should express:

- What this system is trying to accomplish
- Who or what it serves (user-facing, service-facing, internal?)
- The nature of its logic (simulation, workflow, orchestration, etc.)
- Its final expected form (library, tool, engine, application?)

Example expectations for this section: → Should be 3–5 sentences describing the “why” behind the build\
→ Avoid low-level implementation terms\
→ May include genre, domain, or user scenario if known

──────────────────────────────────────────────────────────── SECTION 2 — REQUIRED CAPABILITIES  (Planning Phase 2) ──────────────────────────────────────────────────────────── This section lists all *non-negotiable functional capabilities* of the system. These are outputs or behaviors the system must produce, regardless of how it's implemented.

Example expectations:

- Each bullet should describe a functional requirement
- Include both runtime behaviors and architectural necessities
- Clarify *must-have* features vs optional
- Avoid internal phrasing like “should be modular” unless you mean “must support runtime domain loading”

Also include:

- External interfacing constraints (e.g. “Must expose a JSON API”)
- Critical compatibility requirements (e.g. “Must run on mobile hardware”)
- User flow expectations (if applicable)

──────────────────────────────────────────────────────────── SECTION 3 — DESIGN CONSTRAINTS  (Planning Phase 3) ──────────────────────────────────────────────────────────── This section covers *non-functional* rules that govern how the system is to be built or structured. This includes philosophical rules, enforced boundaries, and coding-level constraints.

Expectations:

- Include all relevant constraints such as:
  - Programming language version
  - Required test framework
  - Rules around mutability or global state
  - Observability/logging requirements
- May reference tooling policies (e.g. must support structured debug output)
- If the project requires separation of logic, declare how (e.g. Core vs Systems vs UI)

If certain anti-patterns are banned (e.g. circular imports, direct file I/O in logic modules), specify them clearly.

──────────────────────────────────────────────────────────── SECTION 4 — ARCHITECTURAL SHAPE  (Planning Phase 4) ──────────────────────────────────────────────────────────── This section outlines the *expected structural shape* of the system, in abstract terms. It defines how modules are expected to be grouped or layered — without naming specific files.

Guidance:

- Declare the major layers of the system (e.g. Core, Systems, Interface)
- Describe if features are organized by *domain* (e.g. combat, inventory) or *role* (e.g. processors, emitters)
- Specify any known architectural patterns to be followed (e.g. event bus, adapter routing, plugin registration)
- If system must be sliceable into deployable vertical features (e.g. milestone-based), say so

Do not describe implementation or file layout here. That’s for the architecture plan. Instead, define the expected *conceptual partitioning* of responsibilities.

──────────────────────────────────────────────────────────── SECTION 5 — GOVERNING PRINCIPLES (EXTERNAL)  (Planning Phase 5) ──────────────────────────────────────────────────────────── This section *references* external principle documents that must be followed during architecture generation. These define things like file structure, tagging rules, adapter constraints, and debug policy.

Expectations:

- Do not duplicate rules here — list the filenames and their function
- Must include any locked architectural principle files
- Must include any tag vocabulary definitions (if required at planning stage)

Example entry:

```
- Architectural_Principles.txt — Defines allowed layers, purity rules, adapter boundaries
- tags_vocab.json — Defines MECE tagging groups for all functions and files
- DebuggerContract.txt — Defines structure of debug output and logging obligations
```

If no such documents exist yet, leave this section empty or write `None yet declared`.

──────────────────────────────────────────────────────────── SECTION 6 — OUTSTANDING OPEN QUESTIONS (OPTIONAL)  (Planning Phase 6) ──────────────────────────────────────────────────────────── List any unresolved decisions or ambiguities that arose during facilitation. These are not blockers but should be addressed early by the architect.

Include:

- Missing declarations (e.g. “Event system is assumed but not confirmed”)
- Unclear priorities (e.g. “Performance vs memory usage tradeoff not declared”)
- Risk flags (e.g. “Data format is not yet finalized”)

This section is optional but highly recommended when the upstream conversation includes assumptions.

────────────────────────────────────────────────────────────

This document concludes the planning phase. No additional prompts, assumptions, or profiles are to be applied by the architect.

