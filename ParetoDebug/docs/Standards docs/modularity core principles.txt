â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“˜ MODULARITY CORE â€” FIVE PATTERNS + ENHANCERS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

These are project-wide architecture principles.  
They should be embedded at all levels: roadmap, phase plans, symbol headers, and actual runtime contracts.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. ğŸ”Œ PLUGIN-CENTRIC REGISTRIES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Enables: Skills, AI behaviors, quests, effects, input modes

Rule:
- Never hardcode behavior into a system
- Use central registries for dynamic resolution

Roadmap Integration:
- Each phase that introduces actions/skills must define registry entries
- Define `SKILL_REGISTRY`, `AI_BEHAVIOR_REGISTRY`, etc. in `core/registries.py`

AI Benefit:
- AI can add new behavior by inserting registry entries only

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2. ğŸ­ ENTITY TEMPLATE LAYER
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Enables: Procedural content, reuse, world gen, testing

Rule:
- Every major entity (`Actor`, `Item`, `Zone`) gets a `template_id`
- Templates are defined as JSON or tagged dicts

Roadmap Integration:
- Any phase that spawns entities must support `from_template(template_id)`
- Template validation can be phase-gated (e.g., v1: no inheritance)

AI Benefit:
- AI can create new entity types by emitting JSON only

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
3. ğŸ§­ UNIFIED WORLD STATE (LIVE SNAPSHOT)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Enables: Save/load, simulation diffing, rewind, traceability

Rule:
- All game state lives in a single `WORLD_STATE` dict
- Systems do not directly reference global variables

Roadmap Integration:
- Phases using the tick loop or quest/faction systems must operate via `world_state` argument
- Output is expected to be a modified or annotated copy

AI Benefit:
- AI can simulate game effects by modifying a world snapshot

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
4. ğŸª¤ SOFT DATA CONTRACTS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Enables: Interchangeability, testing, safety, upgrades

Rule:
- No system expects internal structure from other systems
- Only interacts with defined field names on shared objects

Roadmap Integration:
- Every system in a phase must declare "input expectations" and "output contracts"
- Use header comments or `@contract` annotations

AI Benefit:
- AI understands what data must be present and what gets emitted, without tracing the full call chain

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
5. âš™ï¸ PHASE HOOK DISPATCHERS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Enables: Scalable tick logic, mods, toggles, extensibility

Rule:
- The tick loop has no embedded logic
- Each tick phase is a list of registered functions

Roadmap Integration:
- Tick phases (`perception`, `action`, `cleanup`, `messaging`) call `dispatch_hooks("action", world_state)`
- Each phase plan declares hook modules added

AI Benefit:
- AI can inject or remove systems by modifying a dispatcher list

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ§  CROSS-CUTTING ENHANCERS (MANDATORY)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

These apply to **everything**, always.

âœ… Tags on all entities
- `"tags": ["beast", "nocturnal", "dominion"]`
- Used for filters, effects, AI logic, procedural generation

âœ… Flat references only (no object pointers)
- `"target": "actor_23"`, not `target: actor_obj`
- Portable and AI-friendly

âœ… JSON-first modeling
- All entities, systems, and events should serialize cleanly
- Makes save/load, AI editing, debugging, and UI bridges trivial

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ MVP MINIMUM COMMITMENT
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

To remain on track and modular without overbuilding:

âœ… Use registries from Day 1 for skills and actions  
âœ… Use flat dicts for all entities  
âœ… Route all output through `send_message()`  
âœ… Use `WORLD_STATE` for all shared data  
âœ… Mark placeholders with `@status: "deadend"`  
âœ… All debug statements include `ai_tags`  

This preserves future options *without blocking current delivery*.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
